{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A Journey into Solving the Incompressible Navier-Stokes Equations","text":"<p>This project presents an educational documentation of a numerical solver for the incompressible Navier-Stokes equations, developed as an independent study during my final semester at the University of Colorado Boulder. The goal is to synthesize key concepts and methods used in computational fluid dynamics (CFD) and to make the solver code and methodology accessible to students and researchers. I hope this resource serves as a foundation to build their understanding of CFD and help them develop their own solvers.</p> <p>I would like to thank Prof. Peter Hamlington for his guidance and mentorship throughout this project, and Dr. Colin Towery for his technical support and feedback.</p> <p>If you have any questions or feedback about the material, please feel free to reach out.</p> <p>Pablo Botin pablo.botin@colorado.edu</p>"},{"location":"#contents","title":"Contents","text":"<ol> <li>Introduction</li> <li>Governing Equations</li> <li>Discretization</li> <li>Grid Types</li> <li>Algorithm</li> <li>Poisson Solver</li> <li>Boundary Conditions</li> <li>Solutions</li> </ol>"},{"location":"sections/algorithm/","title":"Algorithm","text":"<p>In this section, we outline and compare two different numerical algorithms employed to solve the incompressible Navier-Stokes equations: the unsplit 1st-order Euler's Method and the Fractional-Step Method. These algorithms differ in their sequence of operations and the way they integrate the pressure and velocity fields over time. I will explain and implement both methods and compare their performance and results in terms of accuracy and computational efficiency.</p>"},{"location":"sections/algorithm/#1st-order-unsplit-eulers-method","title":"1st order unsplit Euler's method","text":"<p>The primary goal of this method is to ensure that the computed velocity field remains divergence-free (mass conserves) at each timestep. This is achieved through two main steps: pressure projection and advection-diffusion, which are alternated to ensure the incompressibility condition.</p> <p></p> <p> Algorithm 1 flowchart: First-Order Unsplit Euler Method </p>"},{"location":"sections/algorithm/#step-1-solving-a-poisson-equation-for-pressure","title":"Step 1. Solving a Poisson equation for pressure.","text":"<p>The first step is to solve the Poisson equation for the pressure, which is derived from the incompressibility condition \\(\\nabla^2 p = \\nabla \\cdot \\mathbf{u}^*\\). The ultimate goal is to calculate the pressure gradient that will ensure zero divergence when performing the advection-diffusion step. </p>"},{"location":"sections/algorithm/#step-2-advection-diffusion-with-pressure-gradient","title":"Step 2. Advection-Diffusion with Pressure Gradient","text":"<p>The advection-diffusion step updates the velocity field by incorporating the pressure gradient (\\(\\nabla p^*\\)) obtained from the solution of the Poisson solver. This step ensures the incompressibility of the flow by adjusting the velocity field based on the pressure distribution, while simultaneously advecting and diffusing the fluid.</p> <p>The advection-diffusion equation, which includes the pressure gradient, is:</p> \\[ \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\left[ -\\frac{1}{\\rho} \\nabla p^* + \\nu \\nabla^2 \\mathbf{u}^n - (\\mathbf{u}^n \\cdot \\nabla) \\mathbf{u}^n + \\mathbf{f} \\right] \\tag{1} \\label{eq:advdiff} \\]"},{"location":"sections/algorithm/#fractional-step-method","title":"Fractional-Step Method","text":"<p>Chorin's fractional step algorithm is a widely used method to solve the incompressible Navier-Stokes equations. The key idea is to first update the velocity field without accounting for the pressure gradient. This yields an intermediate velocity field that may not satisfy the incompressibility constraint, i.e., it may have non-zero divergence.</p> <p>To enforce incompressibility, a pressure correction is introduced. The final velocity field \\(\\mathbf{u}^{n+1}\\) is obtained by subtracting the gradient of the pressure field from the intermediate velocity \\(\\mathbf{u}^*\\). This projection step is written as:</p> \\[ \\mathbf{u}^{n+1} = \\mathbf{u}^* - \\Delta t \\nabla p^{n+1} \\tag{2} \\] <p>As shown in equation (2), the pressure field acts as a correction to ensure the final velocity field satisfies the incompressibility condition.</p> <p></p> <p> Algorithm 2 flowchart: Fractional Step Method. </p>"},{"location":"sections/algorithm/#step-1-advection-diffusion-step","title":"Step 1. Advection-Diffusion Step","text":"<p>In the prediction step, the velocity field is updated by solving the advection-diffusion equation without the pressure gradient term. This means that the velocity evolves based on fluid advection and diffusion effects, but incompressibility is not enforced at this stage. The governing equation is:</p> \\[ \\mathbf{u}^{*} = \\mathbf{u}^n + \\Delta t \\left[\\nu \\nabla^2 \\mathbf{u}^n - (\\mathbf{u}^n \\cdot \\nabla) \\mathbf{u}^n + \\mathbf{f} \\right] \\tag{3} \\] <p>The result of this step is an intermediate velocity field \\(\\mathbf{u}^*\\) that may not satisfy the incompressibility condition, i.e., \\(\\nabla \\cdot \\mathbf{u}^* \\ne 0\\).</p>"},{"location":"sections/algorithm/#step-2-solve-the-poisson-equation","title":"Step 2. Solve the Poisson Equation","text":"<p>To enforce incompressibility, we solve a Poisson equation for pressure, derived by applying the divergence operator to the velocity update in equation (3). The result is:</p> \\[ \\nabla^2 p = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*} \\tag{4} \\] <p>Solving equation (4) yields the pressure distribution needed to correct the intermediate velocity field and enforce the divergence-free constraint.</p>"},{"location":"sections/algorithm/#step-3-correction-step","title":"Step 3. Correction Step","text":"<p>After obtaining the pressure field, the velocity is corrected using a pressure-gradient subtraction. This projection is equivalent to equation (2), but explicitly shows the scaling factor:</p> \\[ \\mathbf{u}^{n+1} = \\mathbf{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p \\tag{5} \\] <p>As shown in equation (5), this correction step ensures that the resulting velocity field \\(\\mathbf{u}^{n+1}\\) is divergence-free, completing the fractional-step update.</p>"},{"location":"sections/boundary_conditions/","title":"Boundary Conditions","text":"<p>Boundary conditions (BCs) are a fundamental component of any numerical simulation, as they define how the system interacts with its surroundings. In the context of incompressible Navier-Stokes solvers, they play a critical role in ensuring accurate and stable solutions. This chapter introduces the main types of boundary conditions used in CFD and describes how they are applied in each of the configurations considered in this notebook.</p>"},{"location":"sections/boundary_conditions/#1-types-of-boundary-conditions","title":"1. Types of Boundary Conditions","text":"<ul> <li> <p>Dirichlet Boundary Condition   Specifies the value of a variable at the boundary. For example, setting a fixed inflow velocity or a zero pressure at a jet. When it comes to walls, there are two commonly used boundary conditions: </p> <ul> <li>No-Slip Condition   A type of Dirichlet BC where velocity is set to zero at solid walls.</li> <li>Slip Condition   Allows tangential velocity but prevents normal velocity at walls, often used in inviscid or simplified flow models.</li> </ul> </li> <li> <p>Neumann Boundary Condition   Specifies the derivative (usually normal to the boundary) of a variable. Commonly used to model outflow conditions or natural walls where flux is zero.</p> </li> <li> <p>Periodic Boundary Condition   Used when the domain wraps around, like in fully developed flows or repeated geometries. Variables exiting one side re-enter on the opposite side.</p> </li> </ul> <p>Setting appropiate boundary conditions is one of the most critical steps in solving the incompressible Navier-Stokes equations. The choice of boundary conditions directly influences the stability, accuracy, and physical realism of the simulation. For example, the no-slip condition on solid walls is commonly used, while zero-gradient conditions are often applied at outflows or boundaries where the flow should not be constrained. Different flow scenarios may require very different boundary treatment. For instance, prescribing a fixed pressure at the outlet versus allowing the flow to develop naturally from a pressure gradient. Even small changes to boundary conditions can lead to drastically different solutions or, in some cases, cause the simulation to diverge or crash entirely.</p> <p>The following figure illustrates how slightly different boundary condition configurations can lead to substantially different solutions, even in a simple channel flow setup:</p> <p></p> <p> Comparison of horizontal velocity fields for two different boundary condition setups in a channel flow. </p> <p>On the left, a uniform velocity profile is imposed at the inlet and the pressure is fixed at the outlet. This results in a developing flow region near the inlet, where the velocity gradually adjusts toward a parabolic profile.</p> <p>On the right, the pressure is fixed at both the inlet and the outlet, and the velocity is not explicitly prescribed. Instead, the flow develops naturally in response to the imposed pressure difference across the domain. In this case, the parabolic velocity profile is already fully developed from the entrance, and no entrance region is observed.</p> <p>This comparison highlights how boundary conditions not only influence numerical stability but also fundamentally shape the physical behavior of the simulated flow.</p> <p>Several practical configurations and their resulting solutions are explored in detail in the Solutions chapter, where we examine how specific combinations of boundary conditions affect the flow behavior.</p>"},{"location":"sections/discretization/","title":"Discretization","text":"<p>The spatial derivative of a function can be approximated by a series of function evaluations at a finite number of discrete points, known as a finite difference. The simplest approximation is to use the difference of two points:</p> \\[ \\frac{\\partial f}{\\partial x} = f' \\approx \\frac{1}{h}(f(x + h) - f(x)) \\tag{1} \\] <p>The accuracy of this approximation depends on where the derivative is assumed to be located relative to the two points in the difference. These are referred to as forward, backward, and central finite difference approximations. If \\(f'\\) is evaluated at \\(x\\), this is known as a forward difference, which is first-order accurate (i.e., the error scales linearly with \\(h\\)). If \\(f'\\) is evaluated at \\(x + h\\), it's a backward difference (also first-order). However, if \\(f'\\) is evaluated at the midpoint, \\(x + \\tfrac{1}{2}h\\), then it becomes a central difference, which is second-order accurate, with error scaling as \\(h^2\\).</p> <p>For a second derivative, one can take the finite difference of the finite difference:</p> \\[ \\frac{\\partial^2 f}{\\partial x^2} \\approx \\frac{1}{h}(f'(x + h) - f'(x)) \\approx \\frac{1}{h^2}(f(x + h) - 2f(x) + f(x-h)) \\tag{2} \\] <p>As shown in (2), the second derivative is typically assumed to be located at the midpoint \\(x\\), making it a second-order central difference approximation.</p> <p>The 12 Steps to CFD lessons use a mixture of forward and central finite differences for interior grid points, and forward or backward differences for Dirichlet boundary conditions, as appropriate. However, for the remainder of this section, we will only discuss central finite differences.</p>"},{"location":"sections/discretization/#central-finite-differences-on-collocated-grids","title":"Central Finite Differences on Collocated Grids","text":"<p>A central finite difference scheme on a collocated solution grid requires a total of three grid points, with the approximation of the derivative located at the central point: the same location where the variable itself is evaluated. In this setup, the spacing between the outer points used in the approximation is \\(h = 2\\Delta x\\), rather than \\(\\Delta x\\) as in the standard grid.</p> <p></p> <p> Schematic of three equally spaced grid points. </p> <p>Since all the solution variables (\\(u\\), \\(v\\), and \\(p\\)), along with their spatial gradients, are collocated at the same grid points, no interpolation schemes are required to compute the pressure field or to advance the Navier-Stokes equations in time.</p> <p>For more information, see the section on collocated grids.</p>"},{"location":"sections/discretization/#central-finite-differences-on-staggered-grids","title":"Central Finite Differences on Staggered Grids","text":"<p>A central finite difference scheme on a staggered grid uses a different set of solution grid points for each variable. Derivatives are evaluated between two adjacent points specific to each variable, and the resulting finite difference approximation lies between them. This location may or may not coincide with the grid point of another variable.</p> <p>This scheme uses a nominal spacing of \\(h = \\Delta x\\), which provides twice the approximation accuracy of the collocated case for the same number of total solution points. This improvement in resolution directly follows from the standard second-derivative approximation in (7).</p> <p>However, the time integration of each variable must occur at its corresponding grid location. For instance, the \\(u\\)-momentum equation must be evaluated at the \\(u\\) grid points, but the associated \\(v\\) and \\(p\\) values, and even the gradients of \\(u\\), are not naturally stored at those locations. As a result, staggered grids require interleaving finite differencing with interpolation.</p> <p></p> <p> Diagram and interpolation formulas for the \\( u \\)-velocity component on a staggered grid. Shows horizontal and vertical interpolation using central differences. </p> <p></p> <p> Diagram and interpolation layout for the \\( v \\)-velocity component on a staggered grid. </p> <p></p> <p> Diagram and interpolation layout for the pressure on a staggered grid. </p> <p>Despite the additional computational effort, staggered grids offer a significant advantage: pressure gradients are evaluated at the correct physical locations required by the Navier-Stokes equations. For example, \\(\\partial p/\\partial x\\) is evaluated exactly where \\(u\\) lives, and the divergence of velocity\u2014\\(\\partial u/\\partial x + \\partial v/\\partial y\\)\u2014is naturally computed at the pressure points.</p> <p>For more details, see the section on staggered grids.</p> <p>To help visualize how the finite-difference stencils are applied on a staggered grid, the following sketches illustrate the storage locations for each variable and the interpolation formulas used in the discretization process. These figures highlight the relative positions of neighboring points used for computing derivatives and show examples of both first-order and second-order central differences. These sketches are intended as conceptual aids.</p> <p></p> <p> Discretization of the u-velocity on its implicit and explicit forms. </p> <p></p> <p> Discretization of the v-velocity on its implicit and explicit forms. </p> <p></p> <p> Discretization of the pressure on its implicit and explicit forms. </p>"},{"location":"sections/governing_equations/","title":"Governing Equations","text":"<p>The incompressible Navier-Stokes equations are fundamental to fluid dynamics and are used to model a wide range of physical phenomena, including airflow over airplane wings, water flow through pipes, and wake formation behind wind turbines. These equations express the conservation of mass (via the continuity equation) and the conservation of momentum (via the momentum equation) within a fluid [Munson et al.].</p> <p>By assuming incompressibility, we neglect variations in density. This is an accepted assumption for many liquid flows and low-speed gas flows. This simplification reduces the complexity of the equations while still capturing the essential physics of many practical problems.</p> <p>The incompressible Navier-Stokes equations consist of:</p> <ul> <li>Mass conservation, ensuring mass conservation.  </li> <li>Momentum conservation, derived from Newton\u2019s second law applied to fluid motion.</li> </ul>"},{"location":"sections/governing_equations/#continuity-equation","title":"Continuity Equation","text":"<p>The continuity equation ensures the conservation of mass in incompressible flows. For a velocity field \\(\\mathbf{u}\\), the equation is written as:</p> \\[ \\nabla \\cdot \\mathbf{u} = 0 \\tag{1} \\] <p>In 2D derivative form, this becomes:</p> \\[ \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 0 \\tag{2} \\]"},{"location":"sections/governing_equations/#momentum-equations","title":"Momentum Equations","text":"<p>The momentum equations describe the conservation of momentum in the fluid, accounting for convection, pressure, diffusion, and external forces. For incompressible flows, they are expressed as:</p> \\[ \\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\frac{1}{\\rho} \\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} \\tag{3} \\] <p>In 2D derivative form:</p> <p>x-Momentum:</p> \\[ \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial x} + \\nu \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + F_x \\tag{4} \\] <p>y-Momentum:</p> \\[ \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial y} + \\nu \\left( \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} \\right) + F_y \\tag{5} \\]"},{"location":"sections/governing_equations/#challenges-in-solving-the-incompressible-navier-stokes-equations","title":"Challenges in Solving the Incompressible Navier-Stokes Equations","text":""},{"location":"sections/governing_equations/#coupling-between-velocity-and-pressure","title":"Coupling Between Velocity and Pressure","text":"<p>A key challenge in solving the incompressible Navier-Stokes equations is the implicit coupling between velocity \\(\\mathbf{u}\\) and pressure \\(p\\). Although the momentum and continuity equations appear decoupled, they are physically interdependent because:</p> <ul> <li>The velocity field influences the resulting pressure distribution.</li> <li>The pressure field must ensure that the velocity field satisfies the incompressibility constraint.</li> </ul> <p>This apparent decoupling gives rise to several numerical challenges:</p> <ul> <li>There is no explicit equation for pressure, so it must be computed indirectly.</li> <li>Without proper treatment, the pressure-velocity relationship can become unstable, causing oscillations or non-physical results</li> </ul> <p>To restore this coupling and enforce incompressibility, a Poisson equation for pressure can be derived from the divergence of the momentum equations. This acts as a surrogate for the continuity equation. A clear and pedagogical explanation of both the derivation of the Poisson equation and the discretization of the governing equations is provided in CFD Python: 12 steps to Navier-Stokes by Barba and Forsyth (Barba &amp; Forsyth, 2014).</p>"},{"location":"sections/governing_equations/#nonlinearity-of-the-momentum-equations","title":"Nonlinearity of the Momentum Equations","text":"<p>The convective term in the momentum equations introduces nonlinearity, which complicates the numerical solution:</p> \\[ (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} \\tag{6} \\] <p>This nonlinearity leads to several numerical challenges:</p> <ul> <li>Instabilities: Small perturbations can grow rapidly unless stabilization techniques are applied.</li> <li>Increased computational cost: Nonlinear systems often require iterative solvers and careful time-stepping. One way to control this is by enforcing a Courant\u2013Friedrichs\u2013Lewy (CFL) condition, which limits the timestep based on local velocity and grid spacing.</li> </ul>"},{"location":"sections/governing_equations/#boundary-conditions","title":"Boundary Conditions","text":"<p>Correctly specifying boundary conditions is critical for both accuracy and stability:</p> <ul> <li>Matching inflow/outflow conditions to avoid artificial reflections.</li> <li>Enforcing the no-slip condition on solid walls.</li> <li>Handling pressure/velocity gradients near boundaries to avoid divergence or loss of accuracy.</li> </ul>"},{"location":"sections/governing_equations/#discretization-challenges","title":"Discretization Challenges","text":"<p>Discretizing the continuous equations introduces trade-offs:</p> <ul> <li>Accuracy vs. cost: Finer grids improve resolution but raise computational demand.</li> <li>Numerical diffusion: Some schemes may over-smooth the solution.</li> <li>Pressure-velocity consistency: Ensuring that the discrete velocity field remains divergence-free is essential.</li> </ul> <p>These difficulties make it clear that choosing the right numerical approach is essential. All the mentioned factors will define the stability and accuracy of the solver. In the next chapter, we\u2019ll look at how to turn the continuous equations into a form that we can solve cell by cell, a process called discretization.</p>"},{"location":"sections/grid_types/","title":"Grid Types","text":"<p>Numerical solvers for the incompressible Navier-Stokes equations often use structured grids to discretize the computational domain. Two common types of grids are collocated grids and staggered grids. This section explains these grid configurations, discusses why staggered grids are often preferred for maintaining incompressibility and compares the results of using the different grids for the same cases. </p> <p></p> <p> Grid Types: Collocated and staggered layout of velocity components in CFD solvers.  Adapted from Matthias M\u00fcller, Ten Minute Physics \u2013 Fluid Simulation, used under the MIT License.  Available at: github.com/matthias-research. </p>"},{"location":"sections/grid_types/#collocated-grid","title":"Collocated Grid","text":"<p>In a collocated grid, all primary flow variables, such as the velocity components \\((u, v)\\) and pressure \\(p\\), are stored at the same spatial locations, typically at the cell centers. This setup simplifies memory management and implementation, especially for structured solvers. However, this arrangement can make it more difficult to numerically couple pressure and velocity, which are already decoupled in the continuous incompressible Navier-Stokes equations. If not treated carefully, this may lead to spurious oscillations, often appearing as a checkerboard pattern in the solution.</p> <p></p> <p> An example of the (undesired) checkerboard effect on a collocated grid. </p> <p>Another challenge is the enforcement of mass conservation. In collocated grids, this can result in non-zero divergence across the domain, particularly in regions with steep velocity gradients or complex boundary interactions. The following divergence maps illustrate this effect across three different scenarios:</p> <ul> <li>Lid-driven cavity: Divergence appears mostly in the corners, likely due to sharp velocity changes imposed by the boundary conditions. </li> </ul> <p> Divergence  map for the lid-driven cavity flow problem. </p> <ul> <li>Channel flow: Divergence is concentrated at the inlet corners. This is likely caused by the sudden onset of flow and the interaction between imposed boundary conditions and the pressure field, which can be challenging to resolve with a collocated grid.</li> </ul> <p></p> <p> Divergence map for the channel flow problem. </p> <ul> <li>Flow around a square obstacle: Divergence appears near the object, where strong recirculation and flow separation make it difficult to maintain mass conservation. </li> </ul> <p> Velocity and divergence map for channel flow around a square obstacle. </p> <ul> <li>Flow accross a wind turbine: Divergence accumulates on the front and back of the wind turbine. This is caused by the strong velocity gradients generated by the axial induction force. </li> </ul> <p></p> <p> Velocity and divergence map for a flow accross a turbine. </p> <p>To mitigate this issues, correction schemes can be employed to stabilize the pressure field. However, adopting a staggered grid potentially offers a more fundamental solution by addressing the root cause of the decoupling.</p>"},{"location":"sections/grid_types/#staggered-grid","title":"Staggered Grid","text":"<p>In staggered grids, different variables are stored at different spatial locations within each grid cell, in this case:</p> <ul> <li>Pressure \\(p\\) is stored at the cell center.</li> <li>The horizontal velocity component \\(u\\) is stored at the center of the vertical cell faces.</li> <li>The vertical velocity component \\(v\\) is stored at the center of the horizontal cell faces.</li> </ul> <p></p> <p> Staggered grid. Variables location layout. </p> <p>This configuration naturally couples pressure and velocity by storing them at offset locations: velocity components on the cell faces and pressure at the cell centers. This staggered layout helps enforce the discretized continuity equation more accurately, potentially getting rid of the divergence and oscillations. As a result, staggered grids are often more effective for incompressible flow solvers where maintaining a divergence-free velocity field is essential.</p> <p>The following figure shows the results for a flow across a wind turbine using a staggered grid. It displays the divergence, pressure, and velocity fields. Notice how the divergence has been effectively eliminated around the turbine and only minimal residual values remain left near the outlet region.</p> <p></p> <p> Divergence, pressure and velocity fields of a flow accross a wind turbine, using a staggered grid.  </p>"},{"location":"sections/grid_types/#mesh-refinement-and-convergence","title":"Mesh Refinement and Convergence","text":"<p>An important indicator of a numerical method is its ability to converge to the true solution as the grid gets refined. In this case, this means that as we increase the number of grid points (i.e., decrease the grid spacing), the numerical solution should become more accurate.</p> <p>To quantify this, I have computed the L2 error between the numerical and analytical solution for the benchmark case of the channel flow compared against the Poiseuille solution. The L2 error provides a measure of the discrepancy between the two solutions.</p> <p>The following figure shows how the error decreases as the mesh resolution increases. The test was performed using a staggered grid and solving the channel flow problem at different resolutions.</p> <p></p> <p> Effect of Mesh Refinement on the accuracy of the solution. </p> <p>The figure above shows the L2 error of the velocity field compared to the Poiseuille analytical solution, plotted against mesh resolution. The concave shape of the curve illustrates how the error decreases with finer grids, demonstrating the proper convergence behavior of the numerical method. However, after a certain resolution, the gain in accuracy becomes marginal compared to the increase in computational cost. Identifying this balance point is a key challenge in practical CFD simulations.</p> <p>The figure below shows how the simulation time increases with mesh resolution. As expected, computational cost rises steeply with finer grids, highlighting the importance of choosing a resolution that offers sufficient accuracy without excessive runtime.</p> <p></p> <p> Simulation cost grows rapidly with mesh refinement, emphasizing the need for a balance between accuracy and performance. </p>"},{"location":"sections/introduction/","title":"Introduction","text":"<p>Fluid dynamics plays an important role in understanding natural phenomena and designing engineering systems. From the flow of air around an airplane wing to the movement of water in rivers, the behavior of fluids is governed by a set of partial differential equations known as the Navier-Stokes equations.</p> <p>The  incompressible Navier-Stokes equations are a simplified version of these equations which describe the motion of fluids with constant density. They are particularly useful for liquid flows and low-speed gas flows where density variations are negligible.</p> <p>This is an educational module designed to help fellow CFD students learn how to build their own solvers tailored to specific flow scenarios. In this notebook, I introduce the governing equations, discuss the challenges of solving them numerically, and seek for an efficient solver implementation. Along the way, I compare different grid types, interpolation strategies, discretization techniques, boundary conditions and iterative solvers to highlight the numerical pros and cons involved. </p>"},{"location":"sections/introduction/#motivation","title":"Motivation","text":"<p>This project originated from a research goal: to develop a solver capable of simulating flow in wind farms, where the interaction between turbines and wind requires both flexibility and a fast resolution. Along the path, I tried with several different approaches:</p> <ol> <li> <p>Semi-Lagrangian Projection. I worked with a solver developed by Matthias M\u00fcller from Ten Minute Physics. The method combines semi-Lagrangian advection, a projection step to enforce continuity, and an added diffusion step to improve stability. While useful for early testing, this approach led to results that didn\u2019t always behave as expected, which motivated me to develop a solver from scratch using a more traditional formulation.</p> </li> <li> <p>1st Order Unsplit Euler with a collocated grid. To better understand the fundamentals, I decided to build my own solver from scratch using Lorena Barba\u2019s CFD Python tutorials as a guide. This approach uses a collocated grid and a specific form of the projection method: it solves the Poisson equation first and then advects using the resulting pressure field. While the implementation helped me solidify my understanding of key numerical components, the solutions were not strictly divergence-free. This raised concerns about the method's consistency, and led me to explore a more classical formulation along with a new grid structure: Chorin\u2019s predictor-corrector method with a staggered grid.</p> </li> <li> <p>Fractional Step Method with a staggered grid. I then implemented a solver using Chorin\u2019s classic predictor\u2013corrector algorithm, this time on a staggered grid structure. This formulation improved pressure\u2013velocity coupling and ensured mass conservation more effectively. I also incorporated more advanced interpolation schemes and special boundary condition treatments to increase the solver's accuracy and flexibility.</p> </li> </ol>"},{"location":"sections/introduction/#objective","title":"Objective","text":"<p>This notebook is intended to be an educational module for other CFD students. It aims to provide a practical guide to building a flow solver from scratch by:</p> <ul> <li>Introducing the incompressible Navier Stokes equations and explain the numerical challenges of their resolution.   </li> <li>Present and discuss different types of grids, discretization, numerical methods, boundary conditions, iterative solvers...   </li> <li>Provide reproducible code with figures. </li> <li>Encourage other students to customize, extend, and adapt these methods to their own projects. </li> </ul>"},{"location":"sections/poisson_solver/","title":"Poisson Solver","text":"<p>In incompressible flows, ensuring mass conservation requires solving the Poisson equation for pressure at each time step, based on the updated velocity field. This step is crucial for projecting the velocity field so that it satisfies the continuity equation.</p> \\[ \\nabla^2 p = \\nabla \\cdot \\mathbf{u}^* \\tag{1} \\] <p>Here, \\(\\mathbf{u}^*\\) is the intermediate (non-divergence-free) velocity field computed from the momentum equation, and \\(p\\) is the pressure field used to correct it.</p> <p>To solve (1) efficiently, two common iterative methods are widely used:</p> <ul> <li>Jacobi Method</li> <li>Gauss-Seidel Method</li> </ul> <p>In this section, we will explain both methods step by step, provide Python implementations, and compare their performance.</p>"},{"location":"sections/poisson_solver/#jacobi-method","title":"Jacobi Method","text":"<p>The Jacobi method computes the solution to the Poisson equation iteratively by solving for each variable in terms of the others using values from the previous iteration.</p>"},{"location":"sections/poisson_solver/#algorithm-steps","title":"Algorithm Steps","text":"<ol> <li>Initialize Variables Begin with an initial guess for the pressure field \\( p \\), and compute the right-hand side \\( b \\) from velocity divergence. </li> <li>Precompute Coefficients To simplify updates, define:  $$ p_{\\text{coef}} = \\frac{1}{2(\\Delta x^2 + \\Delta y^2)} \\tag{2} $$  $$ b_{i,j} \\leftarrow b_{i,j} \\cdot \\frac{2(\\Delta x^2 + \\Delta y^2)\\rho}{\\Delta x^2 \\Delta y^2} \\tag{3} $$ </li> <li>Jacobi Iteration Update pressure on interior points:  $$ p_{i,j}^{(k+1)} = p_{\\text{coef}} \\left[ (p_{i+1,j}^{(k)} + p_{i-1,j}^{(k)}) \\Delta y^2 + (p_{i,j+1}^{(k)} + p_{i,j-1}^{(k)}) \\Delta x^2 \\right] - b_{i,j} \\tag{4} $$ </li> <li>Enforce Boundary Conditions Use homogeneous Neumann boundaries:  $$ \\frac{\\partial p}{\\partial n} = 0 $$ </li> <li>Compute Error After each iteration:  $$ \\text{Error} = \\sqrt{\\frac{1}{N} \\sum_{i,j} \\left( p_{i,j}^{(k+1)} - p_{i,j}^{(k)} \\right)^2} \\tag{5} $$ </li> <li>Check for Convergence Stop when: <ul> <li>Error &lt; tolerance</li> <li>Or maximum iterations reached</li> </ul> </li> <li>Return Final Pressure Field The final \\( p \\) approximately satisfies the Poisson equation within the specified tolerance. </li> </ol> <p><pre><code>def pressure_poisson(p, b, dx, dy, tol, maxiter):\n    \"\"\"\n    Solve the Poisson equation for pressure correction using Jacobi's iterative method.\n\n    Parameters:\n    -----------\n    p : numpy.ndarray\n        Current pressure field. This array will be updated iteratively.\n    b : numpy.ndarray\n        Right-hand side of the Poisson equation, derived from velocity divergence.\n    dx, dy : float\n        Grid spacing in the x and y directions.\n    tol : float\n        Convergence tolerance for the root-mean-square error.\n    maxiter : int\n        Maximum number of iterations. Accelerates the speed at the beginning of the iterations. \n    rho : density. \n\n    Returns:\n    --------\n    numpy.ndarray\n        The updated pressure field that satisfies the Poisson eq. within the specified tolerance.\n\n    Notes:\n    ------\n    - Implements Jacobi's method, iteratively updating the pressure field.\n    - Enforces Neumann boundary conditions (zero pressure gradient) on all domain edges (this is just for the Cavity Flow case). \n    - The method stops when either the error falls below the specified tolerance or the maximum\n      number of iterations is reached.\n    \"\"\"\n    err = np.inf # Initialize huge error.\n    nit = 0 # Reset num iterations.\n    pcoef = 0.5 / (dx**2 + dy**2) # Simplifies code\n    b *= rho * dx**2 * dy**2 / (2*(dx**2 + dy**2))\n\n    while err &gt; tol and nit &lt; maxiter:\n        pn = p.copy()\n\n        p[1:-1, 1:-1] = (pcoef * ((pn[1:-1, 2:] + pn[1:-1, :-2])*dy**2\n                        + (pn[2:, 1:-1] + pn[:-2, 1:-1])*dx**2) - b)\n\n        # BCs. Openfield.\n        p[:, 0] = p[:, 1] # dp/dx=0 at x=0.\n        p[:, -1] = -p[:, -2] # p = 0 at x = L.\n        p[0, :] = p[1, :]   # dp/dy = 0 at y = 0.\n        p[-1, :] = p[-2, :] # dp/dx = 0 at y = 2.\n\n        err = np.mean((p[1:-1, 1:-1] - pn[1:-1, 1:-1])**2)**0.5\n        nit += 1\n\n    return p\n</code></pre> </p>"},{"location":"sections/poisson_solver/#gauss-seidel","title":"Gauss-Seidel","text":"<p>The Gauss-Seidel method improves on Jacobi's iterative solver by updating the pressure values in-place, using the most recent values during each iteration. This results in faster convergence. Additionally, this method has been implemented using Cython for even greater efficiency.</p>"},{"location":"sections/poisson_solver/#algorithm-steps_1","title":"Algorithm Steps","text":"<ol> <li>Initialize variables Start with the current pressure field \\( p \\), and define the right-hand side \\( b \\) of the Poisson equation, derived from the velocity divergence. </li> <li>Precompute coefficients As in the Jacobi method, precompute the update coefficient and scale the RHS:     $$ p_{\\text{coef}} = \\frac{1}{2(\\Delta x^2 + \\Delta y^2)} \\tag{6} $$     $$ b_{i,j} \\leftarrow b_{i,j} \\cdot \\frac{2(\\Delta x^2 + \\Delta y^2) \\rho}{\\Delta x^2 \\Delta y^2} \\tag{7} $$ </li> <li>Gauss-Seidel iteration Loop through the grid and update pressure in-place using:     $$ p_{i,j} = p_{\\text{coef}} \\left[ (p_{i,j+1} + p_{i,j-1}) \\Delta y^2 + (p_{i+1,j} + p_{i-1,j}) \\Delta x^2 \\right] - b_{i,j} \\tag{8} $$ </li> <li>Enforce boundary conditions Apply Neumann boundary conditions:  $$ \\frac{\\partial p}{\\partial n} = 0 $$  Modify as necessary for the physical problem. </li> <li>Compute error Calculate the root-mean-square (RMS) error between iterations:     $$ \\text{Error} = \\sqrt{\\frac{1}{N} \\sum_{i,j} \\left( p_{i,j}^{(k+1)} - p_{i,j}^{(k)} \\right)^2} \\tag{9} $$ </li> <li>Check for convergence Stop iterating if either: <ul> <li>Error is less than the specified tolerance, or</li> <li>The maximum number of iterations is reached.</li> </ul> </li> <li>Output Return the final pressure field, which approximately satisfies the Poisson equation within the defined tolerance. </li> </ol> <pre><code>def pressure_poisson_gauss_seidel(p, b, dx, dy, rho):\n    \"\"\"\n    Solve the Poisson equation for pressure correction using the Gauss-Seidel method.\n\n    This function iteratively solves the pressure Poisson equation, which is derived from \n    the incompressible Navier-Stokes equations to ensure mass conservation. It uses the \n    Gauss-Seidel method for in-place updates, leveraging the latest pressure estimates \n    during each iteration for faster convergence.\n\n    Parameters:\n    -----------\n    p : numpy.ndarray\n        The pressure field (2D array) that needs to be updated in order to satisfy the Poisson equation. \n    b : numpy.ndarray\n        The Poisson's equation RHS (b term, 2D array) derived from the velocity divergence.\n    dx : float\n        Grid spacing in the x-direction.\n    dy : float\n        Grid spacing in the y-direction.\n    rho : float\n        Fluid density, used to scale the source term.\n\n    Returns:\n    --------\n    p : numpy.ndarray\n        Updated pressure field satisfying the Poisson equation within the specified tolerance.\n\n    Key Features:\n    --------------\n    1. In-place updates using Gauss-Seidel accelerate convergence compared to Jacobi's method.\n    2. Enforces Neumann boundary conditions (zero pressure gradient) on all domain edges (this is just for the Cavity Flow case).\n    3. Convergence is determined based on the root-mean-square (RMS) error between iterations.\n    \"\"\"\n    err = np.inf  # Initialize a large error.\n    nit = 0  # Reset the number of iterations.\n    pcoef = 0.5 / (dx**2 + dy**2)  # Precompute coefficient for simplicity.\n    b *= rho * dx**2 * dy**2 / (2 * (dx**2 + dy**2))\n\n    while err &gt; tol and nit &lt; maxiter:\n        pn = p.copy()\n\n        # Gauss-Seidel in-place update\n        p = gauss_seidel_iteration(p, b, pcoef, dx, dy)\n\n        # Apply boundary conditions\n        p[:, 0] = p[:, 1] # dp/dx=0 at x=0.\n        p[:, -1] = -p[:, -2] # p = 0 at x = L.\n        p[0, :] = p[1, :]   # dp/dy = 0 at y = 0.\n        p[-1, :] = p[-2, :] # dp/dx = 0 at y = 2.\n\n        # Calculate error based on the new values\n        err = np.mean((p[1:-1, 1:-1] - pn[1:-1, 1:-1])**2)**0.5\n        nit += 1\n\n    return p\n</code></pre>"},{"location":"sections/poisson_solver/#comparison-of-poisson-solvers-jacobi-vs-gauss-seidel","title":"Comparison of Poisson Solvers: Jacobi vs. Gauss-Seidel","text":"<p>To assess the performance of the Jacobi and Gauss-Seidel methods in solving the Poisson equation, both algorithms were applied to the same flow setup. The figure below shows the resulting divergence fields for each method: the Jacobi solution is on the left, and the Gauss-Seidel solution on the right.</p> <p></p> <p> Divergence field results using Gauss-Seidel (above) and Jacobi (below) solvers. </p> <p>For the same problem setup\u2014identical grid resolution, boundary conditions, and convergence tolerance\u2014the Gauss-Seidel method converged approximately 45% faster, completing in 17.78 seconds compared to 32.21 seconds for the Jacobi solver. Furthermore, the final divergence field computed using Gauss-Seidel was four orders of magnitude smaller, indicating significantly better enforcement of the incompressibility constraint.</p> <p>This performance difference stems from how each method propagates corrections: Jacobi uses only values from the previous iteration, while Gauss-Seidel uses the most recently updated values within the same iteration, improving convergence efficiency. This leads to both faster run times and more accurate pressure fields.</p> <p></p> <p> Execution time and divergence comparison between Jacobi and Gauss-Seidel solvers. </p>"},{"location":"sections/poisson_solver/#performance-optimization-with-cython","title":"Performance Optimization with Cython","text":"<p>To further improve performance, the Gauss-Seidel solver was implemented in Cython\u2014a superset of Python that compiles to C. Cython enables C-like performance while retaining readable Python-like syntax. By compiling the innermost loops of the algorithm, execution time is significantly reduced.</p> <p>```python def gauss_seidel_iteration(cnp.ndarray[cnp.double_t, ndim=2] p,                            cnp.ndarray[cnp.double_t, ndim=2] b,                            double pcoef,                            double dy,                            double dx):     cdef int i, j</p> <pre><code>for i in range(1, p.shape[0] - 1):\n    for j in range(1, p.shape[1] - 1):\n        p[i, j] = pcoef * ((p[i, j+1] + p[i, j-1]) * dy**2 +\n                           (p[i+1, j] + p[i-1, j]) * dx**2) - b[i-1, j-1]\n\nreturn p\n</code></pre>"},{"location":"sections/references/","title":"References","text":"<ul> <li>Barba, Lorena A., and Forsyth, Gilbert F. (2018). CFD Python: the 12 steps to Navier-Stokes equations. Journal of Open Source Education, 1(9), 21. https://doi.org/10.21105/jose.00021 </li> </ul> <p>A popular educational CFD series. Jupyter notebook lessons available at: https://github.com/barbagroup/CFDPython, retrieved April 17, 2025.</p> <ul> <li>Michio (2025). CFD 101: 2D Lid Driven Cavity Flow. Available at: https://github.com/mathworks/2D-Lid-Driven-Cavity-Flow-Incompressible-Navier-Stokes-Solver, retrieved April 17, 2025.</li> </ul> <p>A good introduction to the staggered grid and fractional step method in MATLAB.</p> <ul> <li>Matthias M\u00fcller. Ten Minute Physics \u2013 Fluid Simulation. Available at: https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/17-fluidSim.html, retrieved April 17, 2025.</li> </ul> <p>A real-time flow simulator written in Java for interactive learning, includes an alternative presentation of the fractional step method with Successive Over Relaxation (SOR), a variation of the Gauss-Seidel algorithm for solving the Poisson equation.</p> <ul> <li>Vallisneri, Michele (2024). Solving the Poisson equation with Numpy website, Retrieved October 21, 2024.</li> </ul> <p>A very good introduction to the basics of Poisson solution algorithms in Python and Cython. Includes Jacobi, Gauss-Seidel, and Multigrid methods.</p> <ul> <li>Cython Documentation. Available at: https://cython.org/ </li> </ul> <p>Documentation used for integrating C-level performance in Python with ease.</p> <ul> <li>Chorin, A. J. (1968) \u2013 Numerical Solution of the Navier-Stokes Equations </li> </ul> <p>Original paper introducing the fractional step method for incompressible flow.</p> <ul> <li>Munson, et al., Fundamentals of Fluid Mechanics.</li> </ul> <p>Standard undergraduate textbook covering fluid dynamics principles including the Navier-Stokes equations.</p> <ul> <li>Rhie, C. M., &amp; Chow, W. L. (1983). Numerical study of the turbulent flow past an airfoil with trailing edge separation. AIAA Journal, 21(11), 1525\u20131532. https://doi.org/10.2514/3.8284</li> </ul> <p>A good resource to understand the Rhie-Chow interpolation method to prevent pressure-velocity decoupling on collocated grids.</p> <ul> <li>Burton, T., Sharpe, D., Jenkins, N., &amp; Bossanyi, E. (2011). Wind Energy Handbook (2nd ed.). Wiley. ISBN: 978-0-470-69975-1</li> </ul> <p>Comprehensive reference on wind energy theory, design, and engineering applications.</p>"},{"location":"sections/solutions/","title":"Solutions","text":""},{"location":"sections/solutions/#lid-driven-cavity","title":"Lid-Driven Cavity","text":"<p>We begin with this case because it is the one presented in Lorena Barba\u2019s educational CFD series and widely recognized as a pedagogical introduction to solving the incompressible Navier-Stokes equations. </p> <p>The lid-driven cavity is a classical benchmark problem in computational fluid dynamics, it oftenly used to test the accuracy and stability of numerical solvers for incompressible flows, given its simplicity. The domain consists of a square cavity with stationary walls and a top lid moving at constant horizontal velocity. This setup creates a primary circulating vortex in the center of the cavity, making it an excellent case for evaluating velocity-pressure coupling, vorticity transport, and boundary layer resolution.  </p> Boundary Type Velocity Condition Pressure Condition Top Moving wall (non-slip) u = U<sub>lid</sub>, v = 0 Zero-gradient (Neumann) Bottom Wall (non-slip) u = 0, v = 0 Zero-gradient (Neumann) Left Wall (non-slip) u = 0, v = 0 Zero-gradient (Neumann) Right Wall (non-slip) u = 0, v = 0 Zero-gradient (Neumann) <p>The selected boundary conditions are consistent with the classical formulation of the lid-driven cavity problem. No-slip conditions are applied along all walls, ensuring zero velocity at the boundaries with the static walls. The top boundary (corresponding to the moving lid) is prescribed with a constant horizontal velocity and zero vertical velocity, which drives the internal circulation. Pressure is left unconstrained, with zero-gradient (Neumann) conditions on all boundaries to maintain consistency with the incompressible formulation.</p> <p></p> <p> Velocity streamlines and divergence map for the lid-driven cavity flow problem. </p> <p>The velocity streamlines show a well-defined primary vortex occupying the central region of the cavity, driven by the motion of the top lid. The divergence map confirms that the solution remains nearly divergence-free across the domain, however small regions of accumulated divergence are observed near the top corners, resulting from the radical velocity transition between the non slip conditions of the stationary vertical walls and the moving lid.</p>"},{"location":"sections/solutions/#channel-flow","title":"Channel Flow","text":"<p>In this section, we explore two alternative boundary condition configurations used to model steady, incompressible flow in a 2D channel. Although the geometry remains the same, the outlet treatment differs and leads to slightly different numerical behavior.</p>"},{"location":"sections/solutions/#configuration-1-fixed-inlet-velocity","title":"Configuration 1: Fixed Inlet Velocity","text":"<p>This setup imposes a uniform velocity at the inlet and fixes the pressure at the outlet to anchor the pressure field. This configuration mimics an open channel where the flow is driven by a prescribed inlet velocity and develops downstream under a pressure gradient.</p> Boundary Type Velocity Condition Pressure Condition Inlet Inflow Uniform inflow (Dirichlet) Zero-gradient (Neumann) Outlet Outflow Zero-gradient (Neumann) Fixed pressure (Dirichlet) Top/Bottom Wall No-slip (u = 0, Dirichlet) Zero-gradient (Neumann) <p></p> <p> Divergence map, pressure field and velocity magnitude for configuration 1 of the channel flow problem.  </p> <p>The velocity field shows the expected behavior induced by the no-slip condition at the walls. A strong vertical gradient in the horizontal velocity component develops near the solid boundaries, forming a parabolic-like profile across the height of the channel. Additionally, we can observe how the flow gradually develops along the streamwise direction, transitioning from the uniform inlet condition to the characteristic profile of a fully developed channel flow. The following figure provides a closer look at this velocity profile by comparing simulated profiles at different streamwise locations with the analytical Poiseuille solution. Notice that the orange curve represents a uniform velocity, corresponding to the inlet condition, before the flow begins to develop.</p> <p></p> <p> Horizontal velocity profiles at multiple cross-sections along the channel, compared to the analytical Poiseuille solution. </p> <p>The pressure field remains nearly constant in the vertical direction and exhibits a steady decrease along the length of the channel. This behavior reflects the well known negative pressure gradient that drives the flow in a pressure-driven channel.</p> <p>Although the simulation reaches a steady state, a small region of negative divergence is visible near the inlet. This localized mass imbalance results from the interaction between the imposed inlet velocity and the developed pressure field. In the next configuration, I tried to eliminate this divergence by using boundary conditions that will simulate a fully developed inflow, as if that was not the actual entrance of the pipe. </p>"},{"location":"sections/solutions/#configuration-2-fixed-inletoutlet-pressure","title":"Configuration 2: Fixed Inlet/Outlet Pressure","text":"<p>In this setup, pressure is fixed at both the inlet and the outlet. Rather than prescribing a velocity profile, the flow develops naturally in response to the imposed pressure difference across the domain. This configuration is commonly used to simulate fully developed channel flow driven by a pressure gradient. Notice how the velocity profile is already developed at the entrance, eliminating the entrance region observed in the previous setup.</p> Boundary Type Velocity Condition Pressure Condition Inlet Inflow Zero-gradient (Neumann) p = 4 (Dirichlet) Outlet Outflow Zero-gradient (Neumann) p = 0 (Dirichlet) Top/Bottom Wall No-slip (u = 0, Dirichlet) Zero-gradient (Neumann) <p></p> <p> Velocity magnitude, pressure field, and divergence map for Configuration 2 (pressure-driven flow). </p> <p>The divergence field is similar to the previous case, with a small region of nonzero divergence near the inlet. The magnitude of the divergence is about half for this BC setup, which suggests that the pressure-driven boundary conditions could help minimize artificial divergence introduced by mismatched inflow profiles.</p> <p>With fixed pressure at both the inlet and the outlet, and zero-gradient conditions applied to velocity, the flow adjusts naturally to the imposed pressure difference. The pressure field exhibits a uniform gradient along the length of the channel, as expected for a fully developed, pressure-driven flow.</p> <p>Finally, the velocity field is fully developed from the very entrance of the domain, showing a stable parabolic profile throughout the channel. Unlike Configuration 1, there is no entrance region where the velocity evolves.  </p>"},{"location":"sections/solutions/#wind-turbine-in-open-flow","title":"Wind Turbine in Open Flow","text":"<p>In this case, I simulated an open-channel flow interacting with a wind turbine placed at the center of the domain. The objective is to analyze how the presence of the turbine alters the surrounding velocity, pressure, and divergence fields, and to capture the formation and development of a wake. This setup is representative of utility-scale wind turbine siting, where the inflow is nearly uniform and the behavior of the downstream wake is of particular interest.</p> <p>The effect of the turbine is modeled using the actuator disk theory, a simplified aerodynamic model that treats the turbine as a porous disk imposing a resistive force on the flow. This approach captures the key features of wake formation in a really simplified manner, without resolving individual blades. For a comprehensive understanding of actuator disk theory, see Burton et al. 2011.</p> <p>The axial induction force is introduced as a body force term in the momentum equation, applied over the region representing the rotor. The force acts in the streamwise (x) direction and takes the following form:</p> \\[ f_x(x, y) = -\\frac{1}{2} C_T \\, \\frac{U_{\\infty}^2}{\\Delta x} \\, \\chi(x, y) \\] <p>Where: - \\( f_x(x, y) \\) is the body force per unit mass in the x-direction - \\( C_T \\) is the thrust coefficient - \\( U_{\\infty} \\) is the inlet velocity - \\( \\Delta x \\) is the grid spacing (cell width) in the x-direction - \\( \\chi(x, y) \\) is a boolean function that defines what cells are part of a turbine  </p> <p>This formulation assumes that the actuator force is distributed uniformly over the rotor region, and the grid spacing \\( \\Delta x \\) is used to convert the area-based \\( C_T \\) into a per-volume term. Dividing by \\( \\rho \\) then yields the specific force per unit mass, consistent with how forces are applied in the discretized velocity equation.</p> <p>This formulation results in a distinctive pressure profile along the centerline of the domain, which can be visualized in the figure below. The actuator disk imposes a resistive force that causes a sharp pressure jump across the rotor, with a build-up upstream and a drop downstream. The pressure then gradually returns to the far-field inlet level, which is set to zero throughpout the unaffected region of the flow. This distribution is characteristic of actuator disk theory and reflects the exchange of momentum between the flow and the turbine.</p> <p></p> <p> Pressure distribution along the centerline of the domain. The pressure increases upstream of the rotor, drops sharply across it, and gradually recovers downstream. </p> <p>The wake recovery effect observed downstream of the turbine is captured by the presence of the diffusion term in the momentum equation. As discussed in the Governing Equations chapter, the advection-diffusion formulation inherently includes both the transport of momentum and its redistribution through viscous effects.</p> <p>This case also serves to demonstrate how easily body forces can be implemented in numerical solvers and how their influence affects the rest of the domain. The results show how strong the coupling between the pressure and velocity fields is, and demonstrate the action of viscous diffusion.</p> <p></p> <p> Horizontal velocity field (u-component) for flow through a turbine in open-flow conditions. </p> <p>The velocity field shown above illustrates a uniform inflow imposed at the left boundary. As the flow approaches the turbine, it slows down just upstream of the rotor, forming a stagnation region where the velocity magnitude decreases. Around the outer edges of the turbine, the flow accelerates, demonstrating local conservation of momentum as the fluid redirects around the obstacle. Downstream, a wake develops\u2014a low-velocity region that gradually recovers as momentum diffuses back into the flow.</p> <p></p> <p> Pressure field for flow through a turbine in open-flow conditions. </p> <p>The pressure field displayed above remains near zero across most of the domain, except in the immediate vicinity of the turbine. A region of elevated pressure forms in front of the obstacle, while a region of reduced pressure develops just behind it. This distribution is consistent with the classic pressure signature observed in bluff-body flow.</p> <p></p> <p> Divergence map for flow through a turbine in open-flow conditions. The solution remains nearly divergence-free throughout the domain. </p> <p>The divergence field shown above confirms that the solution is nearly divergence-free across the domain, validating the stability and consistency of the solver. The color scale indicates values on the order of \\(10^{-5}\\), demonstrating that mass conservation is maintained up to numerical precision.</p> Parameter Value Domain Size (L<sub>x</sub>, L<sub>y</sub>) = (6, 2) Grid Resolution nx = 300, ny = 100 Reynolds Number Re = 100 Time Stepping \u0394t = 0.001, steady-state solution Solver Projection method with Jacobi Poisson solver"}]}