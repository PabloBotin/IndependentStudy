{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"INSolver: Incompressible Navier-Stokes Solver","text":"<p>Welcome to the documentation for INSolver, a Python-based solver for the incompressible Navier-Stokes equations.</p>"},{"location":"#contents","title":"Contents","text":"<ol> <li>Introduction</li> <li>Governing Equations</li> <li>Discretization</li> <li>Grid Types</li> <li>Algorithm</li> <li>Poisson Solver</li> <li>Boundary Conditions</li> <li>Results</li> <li>Conclusion</li> </ol>"},{"location":"sections/algorithm/","title":"Algorithm","text":"<p>In this section, we outline and compare two different numerical algorithms employed to solve the incompressible Navier-Stokes equations: Chorin's Projection Method and the Predictor-Corrector Method. These algorithms differ in their sequence of operations and the way they integrate the pressure and velocity fields over time. I will explain and implement both methods and compare their performance and results in terms of accuracy and computational efficiency.</p>"},{"location":"sections/algorithm/#1st-order-unsplit-eulers-method-laurena-barbas-method","title":"1st order unsplit Euler's method (Laurena Barba's method)","text":"<p>The primary goal of this method is to ensure that the computed velocity field remains divergence-free (mass conserves) at each timestep. This is achieved through two main steps: pressure projection and advection-diffusion, which are alternated to ensure the incompressibility condition.</p>"},{"location":"sections/algorithm/#step-1-solving-the-poisson-equation-for-pressure-correction","title":"Step 1. Solving the Poisson equation for pressure correction.","text":"<p>The first step is to solve the Poisson equation for the pressure, which is derived from the incompressibility condition \\(\\nabla^2 p = \\nabla \\cdot \\mathbf{u}^*\\). The ultimate goal is to calculate the pressure gradient that will ensure zero divergence when performing the advection-diffusion step. </p>"},{"location":"sections/algorithm/#step-2-advection-diffusion-with-pressure-gradient","title":"Step 2. Advection-Diffusion with Pressure Gradient.","text":"<p>The advection-diffusion step updates the velocity field by incorporating the pressure gradient (\\(\\nabla p^*\\)) obtained from the solution of the Poisson solver. This step ensures the incompressibility of the flow by adjusting the velocity field based on the pressure distribution, while simultaneously advecting and diffusing the fluid. The advection-diffusion equation, which includes the pressure gradient, is: $$ \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\left[ -\\frac{1}{\\rho} \\nabla p^* + \\nu \\nabla^2 \\mathbf{u}^n - (\\mathbf{u}^n \\cdot \\nabla) \\mathbf{u}^n + \\mathbf{f} \\right] $$</p>"},{"location":"sections/algorithm/#chorins-projection-method","title":"Chorin's Projection method","text":"<p>Chorin's fractional step algorithm is a widely used method to solve fluid dynamics equations, particularly when dealing with incompressible flows. The idea is to perform the advection-diffusion step without considering the pressure gradient. This step gives us an intermediate velocity field that may not be divergence-free (it does not satisfy the incompressibility condition). Then, we correct the predicted velocity field to ensure incompressibility, using the pressure gradient computed from the Poisson equation.</p>"},{"location":"sections/algorithm/#step-1-prediction-step-advection-diffusion","title":"Step 1. Prediction Step (Advection-Diffusion).","text":"<p>In the prediction step, the velocity field is updated by solving the advection-diffusion equation without considering the pressure gradient term. This means that the velocity field evolves based on the advection of the fluid and the diffusion effects, but the incompressibility constraint is not enforced at this stage. $$ \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\left[\\nu \\nabla^2 \\mathbf{u}^n - (\\mathbf{u}^n \\cdot \\nabla) \\mathbf{u}^n + \\mathbf{f} \\right] $$ The result of this step is an intermediate velocity field that may not satisfy the incompressibility condition \u2207\u22c5u=0.</p>"},{"location":"sections/algorithm/#step-2-solve-the-poisson-equation","title":"Step 2. Solve the Poisson Equation.","text":"<p>This step involves solving the Poisson equation for the pressure field with the fractional velocity field (<code>u*</code>).  $$ \\nabla^2 p = \\nabla \\cdot \\mathbf{u}^{} $$ The solution to this equation provides the pressure distribution required to compute the pressure gradient* that will be used to correct the velocity field in order to ensure that it is divergence-free.</p>"},{"location":"sections/algorithm/#step-3-correction-step-apply-pressure-gradient-term","title":"Step 3. Correction Step (Apply Pressure Gradient term)","text":"<p>After solving for the pressure p, we compute the pressure gradient which is the missing used to correct the velocity field. The corrected velocity field is computed by subtracting the pressure gradient term from the intermediate velocity: $$ \\mathbf{u} = \\mathbf{u}^ - \\frac{\\nabla p}{\\rho}\\Delta t $$ This method effectivelly ensures zero divergence* because the Poisson equation is solved for the actual velocity field. </p> <p></p> <p> Chorin's algorithm workflow. </p>"},{"location":"sections/boundary_conditions/","title":"Boundary Conditions","text":"<p>Boundary conditions (BCs) are a fundamental part of any numerical simulation, as they define how the system interacts with its surroundings. In the context of incompressible Navier-Stokes solvers, they play a crucial role in ensuring accurate and stable solutions. This chapter introduces the main types of boundary conditions used in CFD and describes how they are applied in each of the configurations considered in this notebook.</p>"},{"location":"sections/boundary_conditions/#1-types-of-boundary-conditions","title":"1. Types of Boundary Conditions","text":"<ul> <li> <p>Dirichlet Boundary Condition   Specifies the value of a variable at the boundary. For example, setting a fixed velocity (inflow, wall movement) or pressure at a boundary.</p> <ul> <li> <p>No-Slip Condition   A type of Dirichlet BC where velocity is set to zero at solid walls.</p> </li> <li> <p>Slip Condition   Allows tangential velocity but prevents normal velocity at walls, often used in inviscid or simplified flow models.</p> </li> </ul> </li> <li> <p>Neumann Boundary Condition   Specifies the derivative (usually normal to the boundary) of a variable. Commonly used to model outflow conditions or natural walls where flux is zero.</p> </li> <li> <p>Periodic Boundary Condition   Used when the domain wraps around, like in fully developed flows or repeated geometries. Variables exiting one side re-enter on the opposite side.</p> </li> <li> <p>Open/Outflow Boundary   Typically uses a Neumann condition for velocity and a fixed pressure (Dirichlet) to allow flow to exit freely.</p> </li> </ul>"},{"location":"sections/boundary_conditions/#2-boundary-conditions-used-per-case","title":"2. Boundary Conditions Used per Case","text":""},{"location":"sections/boundary_conditions/#lid-driven-cavity","title":"Lid-Driven Cavity","text":"<ul> <li>Top lid: Dirichlet condition for horizontal velocity (set to lid speed), no vertical velocity (Dirichlet = 0).  </li> <li>Other walls: No-slip condition (Dirichlet = 0 for both velocity components).  </li> <li>Pressure: Neumann condition (zero-gradient) at all boundaries; pressure is anchored by setting a reference value at one point.</li> </ul>"},{"location":"sections/boundary_conditions/#channel-flow","title":"Channel Flow","text":"<ul> <li>Inlet: Dirichlet condition for velocity profile (parabolic or constant), Neumann for pressure.  </li> <li>Outlet: Dirichlet condition for pressure (e.g., \\( p = 0 \\)), Neumann for velocity.  </li> <li>Walls: No-slip condition for velocity, Neumann for pressure.</li> </ul>"},{"location":"sections/boundary_conditions/#open-flow","title":"Open Flow","text":"<ul> <li>Inlet: Prescribed velocity (Dirichlet), Neumann for pressure.  </li> <li>Outlet: Neumann for velocity, Dirichlet for pressure.  </li> <li>Top and bottom: Free-slip or open boundaries depending on setup.</li> </ul>"},{"location":"sections/boundary_conditions/#object-in-open-flow","title":"Object in Open Flow","text":"<ul> <li>Object surface: No-slip condition.  </li> <li>Inlet/outlet: Same as in open flow.  </li> <li>Top and bottom: Often treated as open (Neumann), or walls (no-slip), depending on domain size.</li> </ul>"},{"location":"sections/boundary_conditions/#wind-turbine-in-open-flow","title":"Wind Turbine in Open Flow","text":"<ul> <li>Inlet: Dirichlet velocity, Neumann pressure.  </li> <li>Outlet: Neumann velocity, Dirichlet pressure.  </li> <li>Turbine surface: No-slip boundary.  </li> <li>Top and sides: Open boundaries (Neumann for velocity and pressure) or symmetry/slip depending on context.</li> </ul> <p>Let me know if you want this turned into a collapsible section for MkDocs, or if you'd like to add figures for each BC case.</p>"},{"location":"sections/discretization/","title":"Discretization","text":"<p>EXPLAIN how the equations were discretized on the staggered (and collocated) grid, including the different used interpolations. </p>"},{"location":"sections/governing_equations/","title":"Governing Equations","text":"<p>The incompressible Navier-Stokes equations are fundamental to fluid dynamics and are used to model a wide range of physical phenomena, including airflow over airplane wings, water flow through pipes, and wake formation behind wind turbines. These equations express the conservation of mass (via the continuity equation) and the conservation of momentum (via the momentum equation) within a fluid.</p> <p>By assuming incompressibility, we neglect variations in density, an accepted assumption for many liquid flows and low-speed gas flows. This simplification reduces the complexity of the equations while still capturing the essential physics of many practical problems.</p> <p>The incompressible Navier-Stokes equations consist of:</p> <ul> <li>Mass conservation, ensuring mass conservation  </li> <li>Momentum conservation, derived from Newton\u2019s second law applied to fluid motion</li> </ul>"},{"location":"sections/governing_equations/#continuity-equation","title":"Continuity Equation","text":"<p>The continuity equation ensures the conservation of mass in incompressible flows. For a velocity field  \\(\\mathbf{u}\\), the equation is written as \\(\u2207\u22c5\\mathbf{u}= 0\\). In 2D derivative form, it becomes: $$ \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 0 $$</p>"},{"location":"sections/governing_equations/#momentum-equations","title":"Momentum Equations","text":"<p>The momentum equations describe the conservation of momentum in the fluid, considering all the forces involved. For incompressible flows, they are expressed as: $$ \\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} = -\\frac{1}{\\rho} \\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} $$</p> <p>In 2D derivative form:</p> <p>x-Momentum: $$ \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial x} + \\nu \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + F_x $$</p> <p>y-Momentum: $$ \\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial y} + \\nu \\left( \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} \\right) + F_y  $$</p>"},{"location":"sections/governing_equations/#challenges-in-solving-the-incompressible-navier-stokes-equations","title":"Challenges in Solving the Incompressible Navier-Stokes Equations","text":""},{"location":"sections/governing_equations/#coupling-between-velocity-and-pressure","title":"Coupling Between Velocity and Pressure","text":"<p>A key challenge in solving the incompressible Navier-Stokes equations is the implicit coupling between velocity \\(\\mathbf{u}\\) and pressure \\(p\\). Although the momentum and continuity equations appear decoupled, they are physically interdependent because:</p> <ul> <li>The velocity field influences the resulting pressure distribution.</li> <li>The pressure field must ensure that the velocity field satisfies the incompressibility constraint.</li> </ul> <p>This apparent decoupling gives rise to several numerical challenges:</p> <ul> <li>There is no explicit equation for pressure, so it must be computed indirectly.</li> <li>Without proper treatment, the pressure-velocity relationship can become unstable, causing oscillations or non-physical results</li> </ul> <p>To restore this coupling and enforce incompressibility, a Poisson equation for pressure can be derived from the divergence of the momentum equations. This acts as a surrogate for the continuity equation. A clear and pedagogical explanation of both the derivation of the Poisson equation and the discretization of the governing equations is provided in CFD Python: 12 steps to Navier-Stokes by Barba and Forsyth (Barba &amp; Forsyth, 2014).</p>"},{"location":"sections/governing_equations/#nonlinearity-of-the-momentum-equations","title":"Nonlinearity of the Momentum Equations","text":"<p>The convective term in the momentum equations,</p> \\[ (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} \\] <p>introduces nonlinearity, which complicates the numerical solution:</p> <ul> <li>Instabilities: Small errors such as upwinding or artificial diffusion may arise.</li> <li>Increased computational cost: Solving nonlinear systems often requires iterative methods and careful time-stepping, one way to control time-stepping is by applying a CFL condition.</li> </ul>"},{"location":"sections/governing_equations/#boundary-conditions","title":"Boundary Conditions","text":"<p>Correctly specifying boundary conditions is critical for both accuracy and stability:</p> <ul> <li>Matching inflow/outflow conditions to avoid artificial reflections.</li> <li>Enforcing the no-slip condition on solid walls.</li> <li>Handling pressure/velocity gradients near boundaries to avoid divergence or loss of accuracy.</li> </ul>"},{"location":"sections/governing_equations/#discretization-challenges","title":"Discretization Challenges","text":"<p>Discretizing the continuous equations introduces trade-offs:</p> <ul> <li>Accuracy vs. cost: Finer grids improve resolution but raise computational demand.</li> <li>Numerical diffusion: Some schemes may over-smooth the solution.</li> <li>Pressure-velocity consistency: Ensuring that the discrete velocity field remains divergence-free is essential.</li> </ul> <p>These difficulties make it clear that choosing the right numerical approach is essential. All the mentioned factors will define the stability and accuracy of the solver. In the next chapter, we\u2019ll look at how to turn the continuous equations into a form that we can solve cell by cell, a process called discretization.</p>"},{"location":"sections/grid_types/","title":"Grid Types","text":"<p>Numerical solvers for the incompressible Navier-Stokes equations often use structured grids to discretize the computational domain. Two common types of grids are collocated grids and staggered grids. This section explains these grid configurations, discusses why staggered grids are often preferred for maintaining incompressibility and compares the results of using the different grids for the same cases. </p> <p></p> <p> Grid Types: Collocated and staggered </p>"},{"location":"sections/grid_types/#collocated-grid","title":"Collocated Grid","text":"<p>In a collocated grid all flow variables\u2014such as the velocity components \\((u, v)\\) and pressure \\(p\\)\u2014are stored at the same grid points (typically at cell centers). This arrangement simplifies data storage and implementation, especially in structured solvers. However, this can lead to spurious pressure oscillations, often referred to as checkerboard patterns, which can make the numerical solution unstable or non-physical.</p> <p></p> <p> (Undesired) Checkerboard effect  </p> <p>In addition to pressure-velocity decoupling, another potential issue with collocated grids is the failure to fully enforce the mass conservation condition. This can result in non-zero divergence across the domain, particularly in regions with complex flow features or sharp gradients. The following divergence maps highlight this effect in three different scenarios. In the lid-driven cavity case (left), divergence appears primarily at the corners, likely due to abrupt changes in boundary conditions. In the channel flow with a square obstacle (center), and open flow around a wind turbine (right).</p> <p>In addition to pressure-velocity decoupling, another potential issue with collocated grids is the failure to fully enforce the mass conservation condition. This can result in non-zero divergence across the domain, particularly in regions with complex flow features or sharp gradients. The following divergence maps highlight this effect in three different scenarios. In the lid-driven cavity case (left), divergence appears primarily at the corners, most probably due to aggresive changes in boundary conditions. In the channel flow with a square obstacle (center), divergence is concentrated at the inlet corners and around the object, where strong velocity gradients and flow separation make it difficult to maintain a divergence-free field. In the open flow around a wind turbine (right), divergence is observed both in front of and behind the turbine, likely caused by large, concentrated velocity gradients. </p> <p></p> <p> Divergence field for cavity flow. </p> <p></p> <p> Divergence field for channel flow around a square obstacle. </p> <p></p> <p> Divergence field for a turbine (axial induction) in an open flow.  </p> <p>To mitigate this issues, correction schemes can be employed to stabilize the pressure field. However, adopting a staggered grid potentially offers a more fundamental solution by addressing the root cause of the decoupling.</p>"},{"location":"sections/grid_types/#staggered-grid","title":"Staggered Grid","text":"<p>In a staggered grid, different variables are stored at different spatial locations within each grid cell, in this case:</p> <ul> <li>Pressure \\(p\\) is stored at the cell center.</li> <li>The horizontal velocity component \\(u\\) is stored at the center of the vertical cell faces.</li> <li>The vertical velocity component \\(v\\) is stored at the center of the horizontal cell faces.</li> </ul> <p></p> <p> Staggered grid. Variables location layout. </p> <p>This configuration naturally couples pressure and velocity by positioning them at offset locations (velocity components are on the cell faces and pressure at the cell centers). This offset arrangement may help satisfy the discretized continuity equation more accurately. It could also reduce or eliminate pressure oscillations without the need for artificial interpolation, potentially making staggered grids more effective for incompressible flow solvers.</p>"},{"location":"sections/grid_types/#comparison-of-solutions","title":"Comparison of Solutions","text":"<p>To evaluate the practical impact of grid configuration, I implemented both a collocated and a staggered grid version of the solver and ran them on the same test case.</p> <p>INSERT FIGURES OF VELOCITY AND DIVERGENCE FOR COLLOCATED AND STAGGERED.  FIND SIMILAR CASES AND COMPARE. HOW DIFFERENT WERE THEY? CAN I FIND CHECKERBOARD AND NO CHECKERBOARD? </p> <p>EXPLAIN</p> <p>Insert plots showing velocity fields and divergence magnitude for both grid types.</p> <p>This comparison illustrates the numerical robustness and stability of staggered grids for solving the incompressible Navier-Stokes equations.</p>"},{"location":"sections/introduction/","title":"Introduction","text":"<p>Fluid dynamics plays an important role in understanding natural phenomena and designing engineering systems. From the flow of air around an airplane wing to the movement of water in rivers, the behavior of fluids is governed by a set of partial differential equations known as the Navier-Stokes equations.</p> <p>The original motivation for developing this solver was to model wake formation behind wind turbines in a wind farm using a lightweight, efficient computational tool. The goal was to enable fast 2D real-time visualizations, with potential extension into the 3D domain. While this notebook does not focus on that specific application, it centers on the design and implementation of the numerical method behind the solver.</p> <p>This method targets the 2D incompressible Navier-Stokes equations, which describe the motion of fluids with constant density. These equations are particularly relevant for liquid flows and low-speed gas flows where density variations are negligible.</p> <p>In this notebook, we introduce the governing equations, discuss the challenges of solving them numerically, and present an efficient solver implementation. Along the way, we compare different grid types, interpolation strategies, discretization techniques, boundary conditions and iterative solvers to highlight the numerical trade-offs involved. This is an educational module designed to help fellow CFD students learn how to build their own solvers tailored to specific flow scenarios.</p>"},{"location":"sections/introduction/#motivation","title":"Motivation","text":"<p>This project originated from a personal goal: to develop a solver capable of simulating flow in wind farms, where the interaction between turbines and the atmosphere requires both flexibility and precision. The path unfolded as follows:</p> <ol> <li> <p>First approach: Semi-Lagrangian Projection: I worked with a solver developed by Matthias M\u00fcller from Ten Minute Physics. The method combines semi-Lagrangian advection, a projection step to enforce continuity, and an added diffusion step to improve stability. While useful for early testing, this approach led to results that didn\u2019t always behave as expected, which motivated me to develop a solver from scratch using a more traditional formulation.</p> </li> <li> <p>Second approach: Collocated with Barba's method: To better understand the fundamentals, I decided to build my own solver from scratch using Lorena Barba\u2019s CFD Python tutorials as a guide. This approach uses a collocated grid and a specific form of the projection method: it solves the Poisson equation first and then advects using the resulting pressure field. While the implementation helped me solidify my understanding of key numerical components, the solutions were not strictly divergence-free. This raised concerns about the method's consistency, and led me to explore a more classical formulation \u2014 Chorin\u2019s predictor\u2013corrector method \u2014 along with a new grid structure: the staggered grid.</p> </li> <li> <p>Final approach: Staggered grid with Chorin\u2019s method: I then implemented a solver using Chorin\u2019s classic predictor\u2013corrector algorithm, this time on a staggered grid structure. This formulation improved pressure\u2013velocity coupling and ensured mass conservation more effectively. I also incorporated more advanced interpolation schemes and special boundary condition treatments to increase the solver's accuracy and flexibility.</p> </li> </ol>"},{"location":"sections/introduction/#objective","title":"Objective","text":"<p>This notebook is intended to be an educational module for other CFD students. It aims to provide a practical guide to building a flow solver from scratch by:</p> <ul> <li>Introducing the incompressible Navier Stokes equations and explain the numerical challenges of their resolution.   </li> <li>Present and discuss different types of grids, discretization, numerical methods, boundary conditions, iterative solvers...   </li> <li>Provide reproducible code with figures. </li> <li>Encourage other students to customize, extend, and adapt these methods to their own projects.</li> </ul>"},{"location":"sections/poisson_solver/","title":"Poisson solver","text":"<p>In incompressible flows, ensuring mass conservation requires solving the Poisson equation for pressure at each time step, based on the updated velocity field. This step is crucial for projecting the velocity field to satisfy the continuity equation: where \\(\\nabla^2 p = \\nabla \\cdot \\mathbf{u}^*\\) where p is the intermediate velocity field computed from the momentum equation. To solve this equation efficiently, two common iterative solvers are used: Jacobi and Gauss-Seidel methods. In this section, I will explain both methods step by step, provide scripts for their implementation, and compare their performance.</p>"},{"location":"sections/poisson_solver/#jacobi","title":"Jacobi","text":"<p>The Jacobi method computes the solution iteratively by solving for each variable in terms of the others using values from the previous iteration.</p>"},{"location":"sections/poisson_solver/#algorithm-steps","title":"Algorithm steps","text":"<ol> <li>Initialize variables. Start with the current p field and define the right hand side of the Poisson equation (derived from velocity divergence). </li> <li>Precompute coefficients. Precompute p_coef and b, which are adjusted for the grid spacings. $$ p_{\\text{coef}} = \\frac{1}{2(\\Delta x^2 + \\Delta y^2)} $$ $$ b_{i,j} \\leftarrow b_{i,j} \\cdot \\frac{2(\\Delta x^2 + \\Delta y^2) \\rho}{\\Delta x^2 \\Delta y^2} $$ The computation of b depends on the method used (projection or predictor-corrector). </li> <li>Iteration. Jacobian update of p on the interior grid points.  \\(p_{i,j}^{(k+1)} = p_{\\text{coef}} \\left[ (p_{i+1,j}^{(k)} + p_{i-1,j}^{(k)}) \\Delta y^2 + (p_{i,j+1}^{(k)} + p_{i,j-1}^{(k)}) \\Delta x^2 \\right] - b_{i,j}\\)</li> <li>Enforce Boundary Conditions Apply Neumann boundary conditions \\(\\frac{\\partial p}{\\partial n} = 0\\) in this case. This may change depending on the BC problem.</li> <li>Compute Error Calculate the root-mean-square (RMS) error between successive pressure fields: $$ \\text{Error} = \\sqrt{\\frac{1}{N} \\sum_{i,j} \\left( p_{i,j}^{(k+1)} - p_{i,j}^{(k)} \\right)^2} $$</li> <li>End of the iteration    Iteration automatically ends if: A) Error is lower than tolerance. B) Maximum number of iterations is reached.</li> <li>Output Return the final pressure field, which satisfies the Poisson equation within the specified tolerance.</li> </ol> <pre><code>def pressure_poisson(p, b, dx, dy, tol, maxiter):\n    \"\"\"\n    Solve the Poisson equation for pressure correction using Jacobi's iterative method.\n\n    Parameters:\n    -----------\n    p : numpy.ndarray\n        Current pressure field. This array will be updated iteratively.\n    b : numpy.ndarray\n        Right-hand side of the Poisson equation, derived from velocity divergence.\n    dx, dy : float\n        Grid spacing in the x and y directions.\n    tol : float\n        Convergence tolerance for the root-mean-square error.\n    maxiter : int\n        Maximum number of iterations. Accelerates the speed at the beginning of the iterations. \n    rho : density. \n\n    Returns:\n    --------\n    numpy.ndarray\n        The updated pressure field that satisfies the Poisson eq. within the specified tolerance.\n\n    Notes:\n    ------\n    - Implements Jacobi's method, iteratively updating the pressure field.\n    - Enforces Neumann boundary conditions (zero pressure gradient) on all domain edges (this is just for the Cavity Flow case). \n    - The method stops when either the error falls below the specified tolerance or the maximum\n      number of iterations is reached.\n    \"\"\"\n    err = np.inf # Initialize huge error.\n    nit = 0 # Reset num iterations.\n    pcoef = 0.5 / (dx**2 + dy**2) # Simplifies code\n    b *= rho * dx**2 * dy**2 / (2*(dx**2 + dy**2))\n\n    while err &gt; tol and nit &lt; maxiter:\n        pn = p.copy()\n\n        p[1:-1, 1:-1] = (pcoef * ((pn[1:-1, 2:] + pn[1:-1, :-2])*dy**2\n                        + (pn[2:, 1:-1] + pn[:-2, 1:-1])*dx**2) - b)\n\n        # BCs. Openfield.\n        p[:, 0] = p[:, 1] # dp/dx=0 at x=0.\n        p[:, -1] = -p[:, -2] # p = 0 at x = L.\n        p[0, :] = p[1, :]   # dp/dy = 0 at y = 0.\n        p[-1, :] = p[-2, :] # dp/dx = 0 at y = 2.\n\n        err = np.mean((p[1:-1, 1:-1] - pn[1:-1, 1:-1])**2)**0.5\n        nit += 1\n\n    return p\n</code></pre>"},{"location":"sections/poisson_solver/#gauss-seidel","title":"Gauss-Seidel","text":"<p>The Gauss-Seidel method improves on Jacobi's iterative solver by updating the pressure values in-place, making it more computationally efficient. What is more, it has been implemented using Cython for an even faster convergence.</p>"},{"location":"sections/poisson_solver/#algorithm-steps_1","title":"Algorithm steps","text":"<ol> <li>Initialize variables. Start with the current p field &amp; define the RHS (b) of the Poisson equation (derived from velocity divergence). </li> <li>Precompute coefficients. Precompute p_coef and b, which are adjusted for the grid spacings.\\(p_{\\text{coef}} = \\frac{1}{2(\\Delta x^2 + \\Delta y^2)}\\) \\(b_{i,j} \\leftarrow b_{i,j} \\cdot \\frac{2(\\Delta x^2 + \\Delta y^2) \\rho}{\\Delta x^2 \\Delta y^2}\\) </li> <li>Iteration. Loop through the grid, updating the pressure values in-place at each grid point using the formula: \\(p_{i,j} = p_{\\text{coef}} \\left[ (p_{i,j+1} + p_{i,j-1}) \\Delta y^2 + (p_{i+1,j} + p_{i-1,j}) \\Delta x^2 \\right] - b_{i,j}\\)</li> <li>Enforce Boundary Conditions Apply Neumann boundary conditions \\(\\frac{\\partial p}{\\partial n} = 0\\) in this case. This may change depending on the BC problem.</li> <li>Compute Error Calculate the root-mean-square (RMS) error between successive pressure fields: \\(\\text{Error} = \\sqrt{\\frac{1}{N} \\sum_{i,j} \\left( p_{i,j}^{(k+1)} - p_{i,j}^{(k)} \\right)^2}\\)</li> <li>End of the iteration Iteration automatically ends if:      A) Error is lower than tolerance.     B) Maximum number of iterations is reached.</li> <li>Output Return the final pressure field, which satisfies the Poisson equation within the specified tolerance.</li> </ol> <p> Chorin's algorithm schematic. </p> <pre><code>def pressure_poisson_gauss_seidel(p, b, dx, dy, rho):\n    \"\"\"\n    Solve the Poisson equation for pressure correction using the Gauss-Seidel method.\n\n    This function iteratively solves the pressure Poisson equation, which is derived from \n    the incompressible Navier-Stokes equations to ensure mass conservation. It uses the \n    Gauss-Seidel method for in-place updates, leveraging the latest pressure estimates \n    during each iteration for faster convergence.\n\n    Parameters:\n    -----------\n    p : numpy.ndarray\n        The pressure field (2D array) that needs to be updated in order to satisfy the Poisson equation. \n    b : numpy.ndarray\n        The Poisson's equation RHS (b term, 2D array) derived from the velocity divergence.\n    dx : float\n        Grid spacing in the x-direction.\n    dy : float\n        Grid spacing in the y-direction.\n    rho : float\n        Fluid density, used to scale the source term.\n\n    Returns:\n    --------\n    p : numpy.ndarray\n        Updated pressure field satisfying the Poisson equation within the specified tolerance.\n\n    Key Features:\n    --------------\n    1. In-place updates using Gauss-Seidel accelerate convergence compared to Jacobi's method.\n    2. Enforces Neumann boundary conditions (zero pressure gradient) on all domain edges (this is just for the Cavity Flow case).\n    3. Convergence is determined based on the root-mean-square (RMS) error between iterations.\n    \"\"\"\n    err = np.inf  # Initialize a large error.\n    nit = 0  # Reset the number of iterations.\n    pcoef = 0.5 / (dx**2 + dy**2)  # Precompute coefficient for simplicity.\n    b *= rho * dx**2 * dy**2 / (2 * (dx**2 + dy**2))\n\n    while err &gt; tol and nit &lt; maxiter:\n        pn = p.copy()\n\n        # Gauss-Seidel in-place update\n        p = gauss_seidel_iteration(p, b, pcoef, dx, dy)\n\n        # Apply boundary conditions\n        p[:, 0] = p[:, 1] # dp/dx=0 at x=0.\n        p[:, -1] = -p[:, -2] # p = 0 at x = L.\n        p[0, :] = p[1, :]   # dp/dy = 0 at y = 0.\n        p[-1, :] = p[-2, :] # dp/dx = 0 at y = 2.\n\n        # Calculate error based on the new values\n        err = np.mean((p[1:-1, 1:-1] - pn[1:-1, 1:-1])**2)**0.5\n        nit += 1\n\n    return p\n</code></pre>"},{"location":"sections/poisson_solver/#comparison-of-poisson-solvers-jacobi-vs-gauss-seidel","title":"Comparison of Poisson Solvers: Jacobi vs. Gauss-Seidel","text":"<p>To assess the performance of the Jacobi and Gauss-Seidel methods in solving the Poisson equation, both algorithms were applied to the same flow setup. The figure below shows the resulting divergence fields for each method: the Jacobi solution is shown on the left, and the Gauss-Seidel solution on the right.</p> <p></p> <p> Divergence field results using Jacobi (left) and Gauss-Seidel (right) solvers. </p> <p>For the same problem setup, the Gauss-Seidel method converged approximately 45% faster, requiring only 17 seconds compared to 32 seconds for the Jacobi solver. Furthermore, the final velocity field obtained with Gauss-Seidel had a divergence four orders of magnitude smaller than that obtained using Jacobi. This highlights Gauss-Seidel's improved numerical stability and effectiveness in enforcing the incompressibility constraint, making it a more efficient and accurate choice for solving the Poisson equation in this context.</p> <p>What\u2019s more, the Gauss-Seidel solver can be further optimized using Cython, allowing for substantial reductions in computation time by accelerating the most performance-critical loops in the algorithm.</p>"},{"location":"sections/poisson_solver/#performance-optimization-with-cython","title":"Performance Optimization with Cython","text":"<p>To improve the performance of the iterative solver, Cython is used. Cython is a superset of Python that enables C-like performance optimizations while preserving the readability and ease of Python syntax. Compiling Python code to C allows direct and efficient interaction and the algorithm executes much faster.</p> <pre><code>def gauss_seidel_iteration(cnp.ndarray[cnp.double_t, ndim=2] p,\n                           cnp.ndarray[cnp.double_t, ndim=2] b,\n                           double pcoef,\n                           double dy,\n                           double dx):\n    cdef int i,j\n\n    for i in range(1,p.shape[0]-1):\n        for j in range(1,p.shape[1]-1):\n            p[i,j] = pcoef * ((p[i,j+1] + p[i,j-1]) * dy**2\n                                + (p[i+1,j] + p[i-1,j]) * dx**2) - b[i-1,j-1]\n\n    return p\n\n# Instructions for usage:\n# 1. Recompile the pyx file: python setup.py build_ext --inplace\n# 2. Run main.py normally \n</code></pre>"},{"location":"sections/poisson_solver/#convergence-of-the-poisson-solver","title":"Convergence of the Poisson Solver","text":"<p>The convergence behavior of the Gauss-Seidel solver is illustrated in the following figure, which plots the logarithm of the norm of the residual (the difference between successive pressure fields) as a function of the number of iterations. This metric provides a quantitative measure of how rapidly the solution approaches a steady state. The curve exhibits a steep decline during the first 700 iterations, indicating rapid error reduction in the early stages of the solution process. Beyond this point, the slope of the curve decreases, forming a slightly concave shape that reflects slower but continued convergence toward the final solution. This behavior highlights the diminishing returns of additional iterations once the residual has been sufficiently minimized. Therefore, it is important to define an appropriate convergence threshold to find a practical balance between computational efficiency and solution accuracy.</p> <p></p> <p> Convergence of the Poisson solver: logarithm of the residual norm versus number of iterations. </p>"},{"location":"sections/references/","title":"References","text":"<ul> <li> <p>Matthias M\u00fcller, Ten Minute Physics \u2013 Fluid Simulation. GitHub Repository</p> </li> <li> <p>Cython Documentation   For integrating C-level performance in Python with ease.</p> </li> <li> <p>Gauss-Seidel and Jacobi Iterative Methods   Classical solvers for linear systems, often used in Poisson equation discretization.</p> </li> <li> <p>Incompressible Navier-Stokes Lecture Notes \u2013 Kelsea Boom   (Check if publicly available or cite course site.)</p> </li> <li> <p>Lorena A. Barba \u2013 12 Steps to Navier-Stokes   A popular educational CFD series. Available at lorenabarba.com.</p> </li> <li> <p>Barba, L. A., &amp; Forsyth, G. F. (2014). CFD Python: 12 steps to Navier-Stokes. Retrieved from https://github.com/barbagroup/CFDPython</p> </li> <li> <p>A.J. Chorin (1968) \u2013 Numerical Solution of the Navier-Stokes Equations   Seminal paper introducing the projection method for incompressible flow.</p> </li> <li> <p>Peter\u2019s MCEN 3030 Course Textbook   (Check which textbook is used \u2013 possibly Fundamentals of Fluid Mechanics by Munson et al.)</p> </li> </ul>"},{"location":"sections/results/","title":"Results","text":""},{"location":"sections/results/#1-collocated-grid","title":"1. Collocated Grid","text":""},{"location":"sections/results/#11-channel-flow","title":"1.1. Channel Flow","text":"<p>The first test case uses a simple channel flow to evaluate the performance of the collocated grid arrangement. Once the steady state is reached, the velocity and divergence fields are analyzed to assess numerical stability and mass conservation. To validate the solution, the velocity profile at the fully developed region is compared against the analytical Poiseuille solution.</p> <p>Figure: Velocity and divergence fields at steady state, along with velocity profile comparison against Poiseuille flow.</p> <p></p> <p> Steady-state velocity and divergence fields for channel flow (collocated grid), with velocity profile comparison to Poiseuille solution at fully developed region. </p>"},{"location":"sections/results/#12-velocity-field","title":"1.2. Velocity Field","text":"<ul> <li>Behavior of the velocity field (u and v components).</li> <li>Note any divergence or artifacts from decoupling.</li> </ul>"},{"location":"sections/results/#13-convergence","title":"1.3. Convergence","text":"<ul> <li>Number of iterations to reach the stopping criterion.</li> <li>Plot of residual norm vs iterations.</li> </ul>"},{"location":"sections/results/#14-comments","title":"1.4. Comments","text":"<ul> <li>Summary of performance and limitations.</li> <li>Notes on pressure-velocity coupling and grid sensitivity.</li> </ul>"},{"location":"sections/results/#2-staggered-grid","title":"2. Staggered Grid","text":""},{"location":"sections/results/#21-pressure-field","title":"2.1. Pressure Field","text":"<ul> <li>Description of the pressure field using staggered grid.</li> <li>Comparison with collocated approach.</li> </ul>"},{"location":"sections/results/#22-velocity-field","title":"2.2. Velocity Field","text":"<ul> <li>Description of the velocity distribution.</li> <li>Improvements or differences compared to collocated grid.</li> </ul>"},{"location":"sections/results/#23-convergence","title":"2.3. Convergence","text":"<ul> <li>Performance summary: iteration count, residual trends.</li> </ul>"},{"location":"sections/results/#24-comments","title":"2.4. Comments","text":"<ul> <li>Interpretation of results.</li> <li>Benefits and stability of the staggered arrangement.</li> </ul>"}]}